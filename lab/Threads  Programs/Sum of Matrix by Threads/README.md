Assume that we want to compute the sum of all the elements in an `N X N ` matrix of
integers. The problem can be solved by a concurrent algorithm using threads. In this example, the main
thread first generates an N  N matrix of integers. Then it creates N working threads, passing as
parameter a unique row number to each working thread, and waits for all the working threads to
terminate. Each working thread computes the partial sum of a distinct row, and deposits the partial sum
in a corresponding row of a global array int sum[N]. When all the working threads have finished, the
main thread resumes. It computes the total sum by adding the partial sums generated by the working
threads. The following shows the complete C code of the example program
 C4.1. Under Linux, the
program must be compiled as
```
gcc C4.1.c â€“pthread
```

# Output C4.1.C
![Screenshot 2023-05-25 141042_edited](https://github.com/gamalahmed3265/Introduction-to-Operating-Systems/assets/75225936/859b5138-f958-46d0-a9c6-dde6f878e19f)

2. # C4.2

Then it creates two subthreads to sort each of the two parts, and waits for the subthreads to finish.
Each subthread sorts its own range by the same algorithm recursively. When all the subthreads have
finished, the main thread resumes. It prints the sorted array and terminates. As is well known, the
number of sorting steps of quicksort depends on the order of the unsorted data, which affects the
number of threads needed in the qsort program

# Output C4.2.C
![Screenshot 2023-05-25 141310_edited](https://github.com/gamalahmed3265/Introduction-to-Operating-Systems/assets/75225936/a3180260-624c-46ac-bfb9-c0c0da1abbb7)
